//图的定义：G由顶点集V和边集E组成 G=(V,E)
//有向图：E是有向边（弧）的集合。从v到w的弧记为<v,w>，v为弧尾，w为弧头
//无向图：E是无向边（边）集合。一条边记为(v,w)
//简单图&多重图：G中无重复边，没有顶点到自身的边，则G为简单图，否则为多重图
//无向完全图：有n个结点，n(n-1)/2条边，即任意两结点之间都有且仅有一条边
//有向完全图：n个结点，n(n-1)条边，即任意两结点之间有且仅有两条弧一来一回。
//子图V的子集和E的子集若能构成图，则为G子图。若子图的点集与G的点集相同则称为G的生成子图
//连通图：无向图中，G中任意两点连通，则G为连通图，否则非连通。
//连通分量：无向图中的极大连通子图
/**
 * n个顶点的图若边数小于n-1则必为非连通图
 * n个顶点的非连通图至多有(n-1)(n-2)/2条边（其中n-1个顶点形成完全图，剩一个点单着）
 */ 
//强连通图：有向图中一对顶点v到w，w到v都有路径，则称v和w强连通。若G中任意一对顶点都有路径，则G为强连通图
//强连通分量：有向图的极大强连通子图称为强连通分量
/**
 * 一个n个结点的强连通图至少要n条边（构成环）
 */ 
//生成树：包含图中所有顶点的极小连通子图，顶点数为n的图G的生成树有n-1条边。
//生成森林：非连通图中的各个连通分量的生成树构成生成森林。
//顶点的度、入度、出度：度是连到这个顶点的边数记为TD(v)，入度是以某点为终点的弧条数记为ID(v)，出度是以某点为起点的弧条数记为OD(v)
/**
 * 无向图中 所有顶点的度之和 等于 边数的两倍
 * 有向图中点的度为入度和出度之和
 * 有向图中 所有点的入度和 等于 所有点出度和 等于 边数
 */ 
//边的权和网：边上带权的图为网
//稠密图&稀疏图：当|E|<|V|log|V|则可以视为稀疏图
//路径：点v到点w所经过的顶点序列v,a,b,c,...,w称为路径，路径上边数为路径长度，起点与终点相同的路径称为回路（环）
/**
 * 若n个点，有大于n-1条边，则必有环
 */ 
//简单路径：路径上没有重复出现的顶点。除起点和终点外无其他重复点的为简单回路
//距离：从u到v的最短路径若存在则称该路径的路径长度为u到v的距离
//有向树：一顶点入度为0，其余顶点入度为1的有向图

//基本操作：
/**
 * Adjacent(G,x,y)：判断G中是否存在边(x,y)
 *          无/有向图：邻接矩阵O(1)  邻接表O(1)~O(|V|)
 * Neighbors(G,x)：列出G中与点x邻接的边
 *          无向图：邻接矩阵O(|V|) 邻接表O(1)~O(|V|)  有向图：邻接矩阵O(|V|) 邻接表出边：O(1)~O(|V|) 入边：O(|E|)
 * InsertVertex(G,x)：从G中插入点x
 *          无/有向图：邻接矩阵O(1)  邻接表O(1)
 * DeleteVertex(G,x)：从G中删除点x
 *          无向图：邻接矩阵O(|V|)（将一行一列标记）  邻接表O(1)~O(|E|) 有向图：邻接矩阵O(|V|) 邻接表出边：O(1)~O(|V|) 入边：O(|E|)
 * AddEdge(G,x,y)：在G中加一条边(x,y)
 * RemoveEdge(G,x,y)：在G中删除边(x,y)
 * FirstNeighbor(G,x)：求G中点x的第一个邻接点
 * NextNeighbor(G,x,y)：若y是x的一个邻接点，返回x的y的下一个邻接点
 * Get_edge_value(G,x,y)：获得边(x,y)权值
 * Set_edge_value(G,x,y,v)：设置边(x,y)权值为v
 */ 

/**
 * BFS:最坏空间复杂度O(|V|),邻接表：时间复杂度O(|V|+|E|) 邻接矩阵：时间复杂度O(|V|^2)
 * DFS:最坏空间复杂度O(|V|)，邻接表：时间复杂度O(|V|+|E|) 邻接矩阵:时间复杂度O(|V|^2)
 * 最小生成树：G的边权和最小的生成树
 * 最小生成树不唯一，但当图G的各边的权值互不相同时唯一。
 * 
 * Prim算法：O(|V|^2) 适合稠密图
 * 1）任意选一点作为MST的根
 * 2）在G的其余点中选距离MST最近的点，将它加入MST
 * 3）重复2）直到所有点加入MST
 * 
 * Kruskal算法：O(|E|log2(|E|)) 适合稀疏图
 * 1）将所有边排序
 * 3）重复2）直到MST里的边数达到n-1
 */ 

//有向无环图简称DAG图：有向图中不存在环

//拓扑排序
/**
 * AOV网：用DAG表示一个工程，顶点表示一个活动，有向边<vi,vj>表示活动vi必须先于vj进行
 * 拓扑排序：一个DAG图的顶点组成的序列满足：1、每个顶点出现且仅出现一次。2、若A排在B前，则图中不存在B到A的路径
 * 拓扑排序算法描述：
 * 1、从AOV网中选一个没有前驱的顶点并输出
 * 2、从网中删除该顶点和以它为起点的有向边
 * 3、重复1、2、直到AOV网为空或不存在无前驱的顶点，后者说明该图必有环
 * 
 */ 

//关键路径
/**
 * AOE网：顶点表示事件，边表示活动，边权表示活动开销（时间等），称之为AOE网
 * AOE网性质如下：1、只有某顶点的事件发生后从该点起的边（活动）才能开始
 *              2、只有进入某顶点的各边所代表的活动都结束后，该顶点事件才能发生
 * 关键路径：所有路径中具有最大路径长度的路径，关键路径上的活动称为关键活动
 * 关键路径长度也是完成整个工程的最短时间，可能有多条关键路径
 * 
 * 顶点vk的最早发生时间ve(k)：从起点到该点的最长路径长度。决定了所有从vk出发的边的最早开始时间
 * ve(源点)=0
 * ve(k)=max{ve(j)+weight(vj,vk)} vj是vk的某前驱
 * 
 * 顶点vk的最迟发生时间vl(k)：保证工程不延期的情况下vk最迟发生的时间
 * vl(汇点)=ve(汇点)    令vl[1-n]=ve[n]
 * vl(k)=min{vl(j)-weight(vk,vj)} vj是vk某后继
 * 
 * 活动ai最早开始时间e(i):若ai的起点是vk，则e(i)=ve(k)
 * 活动ai最迟开始时间l(i):若ai的终点是vj，则l(i)=vl(j)-weight(ai)
 * 最迟开始时间和最早开始时间差额d(i)=l(i)-e(i)
 * d(i)为0的活动ai是关键活动
 * 
 * 求关键路径步骤：
 * 1）从源点起，令ve(源点)=0,然后按拓扑排序求其余点的ve()
 * 2）从汇点起，令vl(汇点)=ve(汇点)，然后按逆拓扑排序求其余点的vl()
 * 3）根据各点ve()和vl()求每个弧的e()和l()
 * 4）找到所有d()=0的弧，构成关键路径
 */ 