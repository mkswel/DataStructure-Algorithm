//m阶B树：所有结点的平衡因子均等于0的m路平衡查找树
/**保证查找效率：
 * 1、规定m叉查找树中除了根节点外，任何结点至少有 [m/2](上取整) 个分叉，即至少含有 [m/2](上取整)-1 个关键字
 * 2、规定对任何结点的平衡因子都为0（左右子树一样高）
 */

/**B树高度(不包括叶子结点)：
 * 含有n个关键字的m阶B树最小高度：每个结点都塞满，有m-1个关键字,m个分叉  h>=logm(n+1)
 *                   最大高度：让每层的分叉尽可能少，根节点只有两个分叉，其他结点只有[m/2](上取整)个分叉
 *                   记k=[m/2](上取整)则每层的关键字数：1,2(k-1),2k(k-1),2k^2(k-1),...,2k^(h-2)(k-1)
 *                   总关键字数n>=1+2(k-1)+2k(k-1)+2k^2(k-1)+...+2k^(h-2)(k-1)=1+2(k^(h-1)-1)  （若n小于该值，高度就不够h了）
 *                   h<=logk((n+1)/2)+1
 */ 
//5叉排序树结点定义
//每个结点至少有3个分叉，2个关键字
typedef int ElemType; 
struct Node{
    ElemType keys[4];           //一个结点最多4个关键字，5个分叉
    struct Node * child[5];
    int num;                    //结点中的关键字个数
};

//B树插入
/**
 * 对于一个结点N1插入key后导致其关键字数超过上限，则将其第[m/2](上取整)个关键字A插入到N1的父结点Nf的对应位置，
 * A左侧的关键字不动，A右侧的关键字右移到新的结点N2中。若因此导致父结点也超上限，则对父结点继续分裂。
 */ 

//B树删除
/**
 * 若删除的关键字在非终端结点（叶子结点的上一层）,则用其直接前驱或直接后继来代替之
 * 直接前驱：当前关键字左侧指针所指子树中最右下元素
 * 直接后继：当前关键字右侧指针所指子树中最左下元素
 * 
 * 若删除终端结点关键字A：若删过后未低于下限，就直接删
 * 若低于了下限，当右兄弟结点关键字宽裕时，用A后继顶替之，用后继的后继顶替后继的空缺
 *             当左兄弟结点关键字宽裕时，用A前驱顶替之，用前驱的前驱顶替前驱的空缺
 *             当兄弟不够借时，将该结点与兄弟结点以及父结点中对应关键字合并。此时父结点关键字数-1
 *             若父结点因此导致关键字不够的情况时，继续对之进行删除后操作
 * 当根节点关键字数为0时直接将根的左右孩子合并为根（根节点关键字数为1时，只有2子树）
 */ 

//m阶B+树
/**
 * 1、每个分支结点最多m棵子树
 * 2、非叶根结点至少有两棵子树，其他分支结点至少右[m/2](上取整)棵子树
 * 3、结点子树与关键字个数相等
 * 4、每个叶子结点包含全部关键字以及指向相应记录的指针，叶子结点中将关键字按大小顺序排列，且相邻叶子结点按大小顺序相互链接
 * 5、所有分支结点只包含它的各个子结点中关键字最大值和指向子结点的指针
 */ 
