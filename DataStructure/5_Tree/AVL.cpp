//定义：左右子树高度差不超过1的二叉排序树
//平衡因子：左右子树高度差，可取-1，0，1，否则视为不平衡
//最小不平衡子树：如果插入了某结点导致整棵树不平衡，则从插入的结点开始往上走计算每个结点的平衡因子，第一个找到的不平衡结点就是最小不平衡子树的根
//四中调整最小不平衡子树的情况：
/**
 * 插入操作
 * 记最小不平衡子树的根为A
 * 1、LL型：A的左孩子B的左子树上插入新节点导致A成为最小不平衡子树
 *        解决方法：右单旋转，将B作为树的根，A作为B的右孩子，B原来的右子树变为A的左子树
 * ()表示平衡因子，[]表示树高，根据最小平衡树的要求可推出BL、BR、AR最初都必须一样高
 *         (2)A                             B(0)                    
 *           / \           右转             / \                        
 *       (1)B   AR     ---------->       BL   A(0)                         
 *         / \  [h]                   [h+1]  / \                       
 *        BL  BR                            BR  AR                     
 *     [h+1]  [h]                          [h]  [h]   
 * 代码：                 
 * A->lchild = B->rchild;
 * B->rchild = A;
 * Af->l(r)child = B;  //A的父结点的左（右）孩子指向B
 * 
 * 2、RR型：A的右孩子B的右子树上插入新结点导致A成为最小不平衡子树
 *      解决方法：左单旋转，B作为根，A作为B的左孩子，B原本的左孩子变为A的右孩子
 *            A(-2)                      (0)B                   
 *           / \           左转            / \                        
 *          AL  B(-1)  ---------->     (0)A   BR                      
 *         [h] / \                       / \  [h+1]                    
 *            BL  BR                    AL  BL                   
 *           [h]  [h+1]                [h]  [h]    
 * 代码：
 * A->rchild = B->lchild;
 * B->lchld = A;
 * Af->l(r)child = B;
 * 
 * 3、LR型：A的左孩子B的右子树插入新结点...
 *     解决方法：将B的右孩子C左旋替代B，然后再右选替代A
 *            A                            A                            C           
 *           / \                          / \      C右旋到A            /   \         
 *          B  AR                        C  AR    ---------->        B     A                          
 *         / \          C左旋到B         / \                         / \   / \            
 *        BL  C        -------->       B   CR                      BL CL CR AR               
 *           / \                      / \                                           
 *          CL  CR                   BL  CL   
 * 代码：
 * B->rchild = C->lchild;
 * A->lchild = C->rchild;
 * C->lchild = B;
 * C->rchild = A;
 * Af->l(r)child = C;
 * 
 * 4、RL型：A的右孩子B的左子树插入...
 *            A                            A                            C           
 *           / \                          / \      C左旋到A            /   \         
 *          AL  B                        AL  C    ---------->        A     B                          
 *             / \        C右旋到B           / \                     / \   / \            
 *            C   BR      -------->        CL  B                   AL CL CR BR               
 *           / \                              / \                                           
 *          CL  CR                           CR  BR 
 * 
 * 查找效率ASL不超过O(h) 或O(log2(n))
 * n(h)表示深度为h的平衡树中含有最少结点数
 * n(0)=0,n(1)=1,n(2)=2,n(h)=n(h-1)+n(h-2)+1
 *  
 * 
 * 删除操作：O(log2(n))
 * 1、删除结点：方法同二叉排序树的删除
 * 2、一路往上找到最小不平衡子树，未找到则结束
 * 3、找这个最小不平衡子树下的高度最高的儿子和孙子
 * 4、根据儿子和孙子的位置调整（LL，RR，LR，RL）
 * 5、如果调整完后不平衡向上层传导，就继续2、
 *    （对最小不平衡子树的调整可能使得树变矮，继而可能导致上层祖先不平衡）                                  
 */ 