/*单调队列-滑动窗口
  长度为k的窗口在数列上右移，输出每右移一格后窗口内的所有数中的最值
*/

#include<iostream>
using namespace std;
const int N=100010;

int n,k;   //n表示数列元素个数，k表示滑动窗口的长度
int a[N],q[N];  //a[]表示数列,q[]表示下标的队列（以下将q[]称为队列下标，将a[q[]]称为队列元素）

int main()
{
    scanf("%d",&n);
    for(int i=0;i<n;i++)scanf("%d",&a[i]);


    int hh=0,tt=-1;   //初始化队列，队头为hh，队尾为tt
    for(int i=0;i<n;i++)
    {
        if(hh<=tt&&i-k+1>q[hh])hh++;   //如果队不空且队头没跟上滑动窗口时，让队头前进一格
        while(hh<=tt&&a[q[tt]]>=a[i])tt--;  //如果队不空且队尾元素不小于新的元素，就删除队尾元素
        q[++tt]=i;      //将新的元素插到队尾
        if(i>=k-1)printf("%d",a[q[hh]]);  /*当滑动窗口完全进入数列时，开始输出，输出窗口内的最小数
        （最初窗口右端与第一个元素对齐，当右移到窗口左端与第一个元素对齐时，窗口完全进入数列）*/
    }
    /*原理：（1）队尾的处理类似单调栈（2）队头的处理是要保证队列要跟上窗口的移动速度，让队列与窗口同步
    **因此创建的队列是单调增的，队列中的最小元素显然就是队头
    */
    puts(""); //回车
    hh=0,tt=-1;
    for(int i=0;i<n;i++)     //以同样方法求窗口内最大数
    {
        if(hh<=tt&&i-k+1>q[hh])hh++;
        while(hh<=tt&&a[q[tt]]<=a[i])tt--;
        q[++tt]=i;
        if(i>=k-1)printf("%d",a[q[hh]]);
    }
    puts("");

    return 0;

}