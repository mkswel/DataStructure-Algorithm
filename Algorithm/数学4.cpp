
/**
 * NIM博弈
 * 
 * 给定N堆物品，第i堆物品有Ai个。两名玩家轮流行动，每次可以任选一堆，取走任意多个物品，可把一堆取光，但不能不取。
 * 取走最后一件物品者获胜。两人都采取最优策略，问先手是否必胜。
 * 
 * 定理：先手必胜，当且仅当 A1 ^ A2 ^ … ^ An != 0 （^异或）
 * 证明：
 * 1)在面对局面0^0^...^0时，即没有物品，这时先手必输
 * 2)在面对局面A1^A2...^An=X(X!=0)时，即所有堆的物品数量异或和不为0，证明这时总能执行一步取物品的操作，将局面转化为异或和为0的局面
 *      记X的二进制中最高`位1是在第k位，则A1,A2,...,An中至少有一个数Ai，Ai的第k位是1（否则所有数第k位都是0，X的第k位也必定是0，矛盾）
 *      可以说明Ai^X<Ai（Ai^X的第k位变成了0，显然小于Ai），那么这时只要执行操作：从第i堆物品中取走Ai-Ai^X个物品，那么原来的Ai就替换为Ai^X，
 *      这时局面为A1^A2^...^Ai^X^...^An=X^X=0，得证
 * 3)在面对局面A1^A2...^An=0时，即所有堆的物品数量异或和为0，证明这时无论执行哪一步取物品的操作，都必将局面转化为异或和不为0的局面
 *      假设存在一种取物品的操作可以将局面维持在异或和为0的局面，设这样一个操作是从第i堆中取出h个物品，那么Ai会变为Ai-h,
 *      这时局势变为A1^A2^...^Ai-h^...^An=0，将其与原式相异或，得Ai^(Ai-h)=0，说明Ai=Ai-h，显然假设不成立。
 * 根据以上三条，定理得证
*/


/**
 * Mex运算
 * 设S表示一个非负整数集合。定义mex(S)为求出不属于集合S的最小非负整数的运算，即：
 * mex(S) = min{x}, x属于自然数，且x不属于S
 *
 * SG函数
 * 在有向图游戏中，对于每个节点x，设从x出发共有k条有向边，分别到达节点y1, y2, …, yk，
 * 定义SG(x)为x的后继节点y1, y2, …, yk 的SG函数值构成的集合再执行mex(S)运算的结果，即：
 * SG(x) = mex({SG(y1), SG(y2), …, SG(yk)})
 * 特别地，整个有向图游戏G的SG函数值被定义为有向图游戏起点s的SG函数值，即SG(G) = SG(s)。终点（出度为0）的SG值为0
 * 
 * 定理1：
 * 有向图游戏的某个局面必胜，当且仅当该局面对应节点的SG函数值大于0。
 * 有向图游戏的某个局面必败，当且仅当该局面对应节点的SG函数值等于0。
 * 
 * 定理1证明：
 * 1)终点SG值为0（处于终点局面必败）
 * 2)根据Mex运算，SG不等于0的局面都存在一个SG等于0的后继局面
 * 3)根据Mex运算，SG等于0的局面的所有后继局面的SG值都不等于0
 * 
 * 定理2：
 * 设G1, G2, …, Gm 是m个有向图游戏。定义有向图游戏G，它的行动规则是任选某个有向图游戏Gi，并在Gi上行动一步。G被称为有向图游戏G1, G2, …, Gm的和。
 * 有向图游戏的和的SG函数值等于它包含的各个子游戏SG函数值的异或和，即：
 * SG(G) = SG(G1) ^ SG(G2) ^ … ^ SG(Gm)
 * 
 * 定理2证明类似NIM博弈证明
*/


#include <unordered_set>
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;
/*背景：在NIM博弈问题中，加一条：每次只能取规定范围内数量的物品（如一次只能取2或5个），如果无法取到，则认输*/
//原理：将每堆物品都看作是一个单独的有向图游戏，物品的个数表示一个局面

//sg函数
const int N=110,M=10010;
int n,m;
int s[N],f[M];  //s表示一次可以取的物品数量,f表示一堆物品中物品的数量的SG值f初始化为-1
int sg(int x)   //返回物品数量是x的一堆物品的SG值
{
    if(f[x]!=-1)return f[x];  //如果初始数量为x的一堆物品已经更新过，就直接返回
    unordered_set<int> S;    //用哈希表存储当前局面的每个后继局面的SG值
    for(int i=0;i<m;i++)  //遍历所有取法（即所有后继局面）
    {
        int sum = s[i];   
        if(x>=sum)S.insert(sg(x-sum));  //如果取法可行，将取完后的局面加入哈希表中
    }
    for(int i=0;;i++)   //Mex运算
        if(!S.count(i))
            return f[x]=i;
}
int main()
{
    cin>>m;   //可行取法的种数
    for(int i=0;i<m;i++)cin>>s[i];
    cin>>n;   //物品堆数
    memset(f,-1,sizeof f);
    int res = 0;
    for(int i=0;i<n;i++)
    {
        int x;
        cin>>x;  //当前堆物品数量
        res^=sg(x);
    }
    if(res)puts("先手必胜");
    else puts("先手必败");
    return 0;
}