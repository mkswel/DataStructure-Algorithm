/*kmp
  搜索主字符串里所有和目标字符串相同的子串的起始位置
*/

#include<iostream>
using namespace std;

const int N=10010,M=100010;
int n,m;          //目标字符串长度n,主串长度m
char p[N],s[M];  //目标字符串p[]，主串s[]
int ne[N];        //存储目标字符串的前缀子串的最大相同前后缀长度



int main()
{
    scanf("%d%d%d%d",&n,p+1,&m,s+1);   //定义下标从1开始


    //求字符串最大相同前后缀的长度，相当于对目标字符串本身做一次搜索操作
    for(int i=2,j=0;i<=n;i++)   //i从2开始，j+1从1开始（由于规定长度为1的字符串的最大相同前后缀长度为0，故直接从2开始）
    {
        while(j&&p[i]!=p[j+1])j=ne[j];    //如果j+1大于1且i位和j+1位不匹配，就让j更新为ne[j](每次都是主串的i位和目标串的j+1位作匹配)
        if(p[i]==p[j+1])j++;             //如果i位和j+1位匹配，就让j前进一格
        ne[i]=j;     //此时的j就是长度为i的前缀子串的最大相同前后缀长度
    }
    

    //对主串进行搜索
    for(int i=1,j=0;i<=m;i++)
    {
        while(j&&s[i]!=p[j+1])j=ne[j];  //如果s[]上i位与p[]上j+1位不匹配，让j更新为ne[j]（相当于让p[]前进到下一个能够进行匹配的位置）
        if(s[i]==p[j+1])j++;      //如果匹配成功，就让j前进一格，再和下一个i匹配
        if(j==n)  //匹配成功
        {
            printf("%d",i-n+1);  //输出匹配成功的字符串的起始位置的下标（从1开始）
            j=ne[j];   //继续让p[]前进

        }//如果j一直更新到0还没有匹配成功，直接让i更新到s[]的下一个位置
    }
}
