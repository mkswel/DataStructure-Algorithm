/*状态压缩DP*/

//********************************************************************************
//例1
/*
求n行m列的矩形完全放下若干个1*2小矩形的方式的最多种数，要求输入多组样例
*/

/*
思路：由于只要摆完横向摆放的小矩形，竖向摆放的矩形的摆放方式就固定了，故只要考虑有多少种横向摆放小矩形的方式就行
对于第i列，要求在该列中从前一列伸出来的小正方形（横向摆放的矩形由一前一后两个小正方形组成）的摆放格式必须满足：
1）小正方形之间的空格必须为偶数个；
2）小正方形所在矩形不能和以前的矩形重叠；

将第i列各行是否占有小正方形的情况以二进制方式设为j，记f[i][j]表示从第1列起一直摆到第i列，且第i列中各行【来自第i-1列摆放的矩形的右半块】的摆法为j的所有种类数
*/
#include<iostream>
#include<algorithm>
#include<cstring>

using namespace std;


const int N=12,M=1<<N;   
int  n,m;
long long f[N][M];
bool st[M];

int main()
{
    int n,m;
    while(cin>>n>>m,n||m)
    {
        memset(f,0,sizeof f);

        //预处理所有在一列中满足任意相邻两小正方形之间的空格数为偶数的摆法种数
        for(int i=0;i<1<<n;i++) //一列有2^n种摆法
        {
            st[i]=true;        //默认第i种摆法为真
            int cnt=0;         //记相邻的两小正方形间是否是奇数个空格
            for(int j=0;j<n;j++)//遍历每一行
            {
                if(i>>j&1)//如果这行是小正方形
                {
                    if(cnt&1)st[i]=false;   //如果cnt是奇数则该摆放方式非法
                    cnt=0;                  //重置0，判断下一相邻两正方形间情况
                }
                else cnt++;      //如果该行是空格，计数器加1
            }
                       
            if(cnt&1)st[i]=false;//判断最后一段连续空格是否为奇数
        }

        //DP
            f[0][0]=1;   //第1行全为空格的摆放方式只有一种，即什么都不放
            for(int i=1;i<=m;i++)               //遍历每列
                for(int j=0;j<1<<n;j++)         //遍历第i列的所有摆法
                    for(int k=0;k<1<<n;k++)     //遍历第i-1列的所有摆法
                        if((j&k)==0&&st[j|k])   //如果两列中没有重叠且满足偶数空格
                            f[i][j]+=f[i-1][k];//加上这种摆法



        cout<<f[m][0]<<endl;
    }


        
        return 0;
    
}



//********************************************************************************
//例2

/*给定有0~n-1节点的带权无向图，求从起点0走到终点n-1的最短Hamilton路径,Hamilton路径表示不重不漏的走过所有点的路径*/

/*思路：可以利用二进制表示每个点是否走过，整体表示成一种路径走法，即状态压缩的含义。f[i][j]表示集合：从起点0到点i的途径点状态为j的所有走法中最短的路径长
计算：记k表示路径上倒数第二个点，用f[k][p]表示从0走到k的途中不经过i的所有走法中最短路径长
原理：两边之和大于第三边
*/

#include<iostream>
#include<algorithm>
#include<cstring>

using namespace std;

const int N=20,M=1<<N;

int n;   //节点数
int w[N][N];  //无向图权重
int f[N][M];

int main()
{
    cin>>n;
    for(int i=0;i<n;i++)
        for(int j=0;j<n;j++)
            cin>>w[i][j];

    memset(f,0x3f,sizeof f);    //初始化所有距离无穷大
    f[0][1]=0;                  //0走到0距离为0
    for(int j=0;j<1<<n;j++)     //遍历所有走法,j为n+1位的二进制数
    {
        for(int i=0;i<n;i++)
            if(j>>i&1)           //由于是从0走到i，故经过i的走法符合要求
                for(int k=0;k<n;k++)
                    if((j-(1<<i))>>k&1)//除去i以外，经过k的走法符合要求
                        f[i][j]=min(f[i][j],f[k][j-(1<<i)]+w[k][i]);
    }
    cout<<f[n-1][(1<<n)-1]<<endl;//输出走到n-1，途径所有点的最短路径长
    return 0;
}



